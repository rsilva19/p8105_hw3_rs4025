---
title: "p8105_hw3_rs4025"
author: "Rebecca Silva"
date: "10/4/2019"
output: github_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
	echo = TRUE,
	warning = FALSE,
	fig.width = 8, 
  fig.height = 6,
  out.width = "90%"
)
options(
  ggplot2.continuous.colour = "viridis",
  ggplot2.continuous.fill = "viridis"
)

#scale_colour_discrete = scale_colour_viridis_d
#scale_fill_discrete = scale_fill_viridis_d
#theme_set(theme_minimal() + theme(legend.position = "bottom"))

library(tidyverse)
library(viridis)
library(p8105.datasets)
library(kableExtra)
library(httr)
library(jsonlite)
library(patchwork) 
```

# Questions: 

+ delete/renumber tables 
+ plot for prob 1?
+ add labels and titles to all plots! and follow rubric 
+ is "patchwork" pkg already in one of my packages
+ still need to comment on findings of prob 2

## Problem 1 

# write a short description of the dataset, noting the size and structure of the data, describing some key variables, and giving illstrative examples of observations. 

The `instacart` dataset gives infomation about online grocery shopping in 2017 using the grocery service, Instacart. It has `r nrow(instacart)` observations where each observation represents a specific product from a specific order number. There are `r ncol(instacart)` variables, 4 of which are character variables, and 11 of which are integer variables. Some key variables and ones that we focus on are as follows: 

* `order_id`: order number 
* `product_id`: product number
* `user_id`: user number
* `order_number`: sequence number of order for user
* `product_name` (character): name/type of product
* `aisle_id`: aisle_id
* `aisle` (character): sorts of products aisle contains 
* `department` (character): name of department

(could list first the ones that are self explanatory?)

# note order of key vars

# Q: give illstrative examples of observations ?

To give an example of the dataset, the first 3 observations are shown below in Table 1. 
```{r}
head = head(instacart, 3) 
knitr::kable(head, 
             caption = "Table 1: First 10 Observation of Instacart dataset")
```

# How many aisles are there, and which aisles are the most items ordered from?

```{r}
aisle = 
  instacart %>% 
  group_by(aisle) %>%   ## dont think i need aisle_id
  summarize(n = n()) %>% 
  arrange(desc(n))
```

There are `r nrow(aisle)` aisles in the online grocery store, the most popular of which are fresh vegetables, fresh fruits, and packaged vegetables and fruit.

```{r}
knitr::kable(head(aisle,3), 
             caption = "Table 2: Top 3 Most Popular Aisles")
```


# Make a plot that shows the number of items ordered in each aisle, limiting this to aisles with more than 10000 items ordered. Arrange aisles sensibly, and organize your plot so others can read it.

# Q: do not know what he wants (cld order by department? no)
```{r}
aisle %>% 
  filter( n > 10000) %>% 
  ggplot(aes(x = aisle_id, fill = aisle)) + 
  geom_histogram() + 
  labs(
    title = "Number of Items by Aisle",
    x = "Aisle Number",
    y = "Number of Items")


## the correct one- i think 
aisle %>% 
  ungroup() %>% 
  mutate(aisle = forcats::fct_reorder(aisle, n)) %>% 
  filter( n > 10000) %>% 
  ggplot(aes(x = aisle, y = n)) + 
  geom_point() + 
  labs(
    title = "Number of Items by Aisle",
    x = "Aisle",
    y = "Number of Items") +
  theme(axis.text.x = element_text(angle = 90))

## try faceting by department -- not pretty
instacart %>% 
  group_by(department, aisle) %>% 
  summarize(n = n()) %>% 
  ungroup() %>% 
  mutate(aisle = forcats::fct_reorder(aisle, n)) %>% 
  filter( n > 10000) %>% 
  ggplot(aes(x = aisle, y = n)) + 
  geom_point() + 
  facet_grid(. ~ department) + 
  labs(
    title = "Number of Items by Aisle",
    x = "Aisle",
    y = "Number of Items") +
  theme(axis.text.x = element_text(angle = 90))

```

# Make a table showing the three most popular items in each of the aisles “baking ingredients”, “dog food care”, and “packaged vegetables fruits”. Include the number of times each item is ordered in your table.

```{r}
table_aisle = 
  instacart %>% 
  filter(aisle %in% c("baking ingredients",
                      "dog food care", 
                      "packaged vegetables fruits")) %>% 
  group_by(aisle, product_name) %>% 
  summarise(n = n()) %>% 
  mutate(rank = min_rank(desc(n))) %>% 
  filter(rank < 4) %>% 
  arrange(desc(n)) %>% 
  select(-rank)
        
knitr::kable(table_aisle, 
            caption = "Most popular items from Baking Ingredients, Dog Food Care, and Packaged Vegetables and Fruit")
```

Make a table showing the mean hour of the day at which Pink Lady Apples and Coffee Ice Cream are ordered on each day of the week; format this table for human readers (i.e. produce a 2 x 7 table)

note: I rounded mean hour to closest hour
#Q: still dont know if I should leave order_dow as is or covert to day of week w mutate (code is b) 
```{r}
mean_table = 
  instacart %>% 
  filter( product_name %in% c("Pink Lady Apples", "Coffee Ice Cream")) %>% 
  select( product_name, order_dow, order_hour_of_day) %>% 
  group_by( product_name, order_dow) %>% 
  summarize(mean = round(mean(order_hour_of_day))) %>% 
  pivot_wider(
    names_from = order_dow, 
    values_from = mean)

#mutate(order_dow = recode(as.character(order_dow), `1` = "Monday", `2` = "Tuesday")) %>%

knitr::kable(mean_table, 
            caption = "Mean Hour of Day for Orders of Pink Lady Apples and Coffee Ice Cream")
```





## Problem 2 

# Q: format the data to use appropriate variable names? - copy and paste what he has? variable names seem fine but last two are diff -  i changed locationabbr and locationdesc to state and country but maybe should use what he does 

```{r}
# var names  
var_names = GET("https://chronicdata.cdc.gov/views/acme-vg9e.json") %>%
  content("text") %>%
  fromJSON() %>% 
  .[["columns"]] %>% 
  .[["name"]] %>% 
  .[-23]

brfss_smart2010_2 = 
  GET("https://chronicdata.cdc.gov/views/acme-vg9e/rows.json") %>% 
  content("text") %>%
  fromJSON() %>% 
  .[["data"]]

row_as_tibble = function(row_as_list, var_names) {
  var_list = row_as_list[9:30]
  names(var_list) = var_names 
  var_list[sapply(var_list, is.null)] <- NULL
  as_tibble(var_list, validate = FALSE)
}

brfss_smart2010_2 = 
  brfss_smart2010_2 %>% 
  map(.x = ., ~row_as_tibble(.x, var_names)) %>% 
  bind_rows
```

my work (not using his code)
```{r}
brfss_smart2010 = 
  brfss_smart2010 %>% 
  map(.x = ., ~row_as_tibble(.x, var_names)) %>% 
  bind_rows


# data cleaning
brfss = 
  janitor::clean_names(brfss_smart2010) %>% 
  separate(locationdesc, 
           into = c("state", "county"), 
           sep = " - ") %>% 
  select(- locationabbr) %>% 
  filter( topic == "Overall Health",
          response %in% c("Poor", "Fair","Good", "Very good", "Excellent")) %>% 
   mutate(response = forcats::fct_relevel(response, c("Poor", "Fair","Good", "Very good", "Excellent")))

```

# COMMENT on the results of each:

# In 2002, which states were observed at 7 or more locations? What about in 2010?

# Q: doing this wrong bc I get 0 or each 

```{r}
brfss_2002 = 
  brfss %>% 
  filter( year == 2002) %>% 
  group_by(state, county) %>% 
  summarize( n_locations = n()) %>% 
  filter( n_locations >= 7)

brfss_2010 = 
  brfss %>% 
  filter( year == 2010) %>% 
  group_by(state, county) %>% 
  summarize( n_locations = n()) %>% 
  filter( n_locations >= 7)
```

In 2002 all states were observated at 5 locations so no states were observed at 7 or more. On the other hand, in 2010, ... (also get 0)

# Construct a dataset that is limited to Excellent responses, and contains, year, state, and a variable that averages the data_value across locations within a state.
# Make a “spaghetti” plot of this average value over time within a state (that is, make a plot showing a line for each state across years – the geom_line geometry and group aesthetic will help).

```{r}
brfss_excellent = 
  brfss %>% 
  filter( response == "Excellent") %>% 
  group_by(year, state) %>% 
  summarize(avg_data_value = mean(data_value,  na.rm = TRUE)) 

brfss_excellent %>% 
  ggplot(aes( x = year, y = avg_data_value)) + 
  geom_line(aes(group = state))

# if want color too (not good i think)
brfss_excellent %>% 
  ggplot(aes( x = year, y = avg_data_value, color = state)) + 
  geom_line(aes(group = state))
```


# Make a two-panel plot showing, for the years 2006, and 2010, distribution of data_value for responses (“Poor” to “Excellent”) among locations in NY State.

```{r}
# plot 1 (2006) 
plot_2006 = 
  brfss %>% 
  filter( year == 2006, state == "NY") %>% 
  ggplot(aes(x = response, y = data_value)) + 
  geom_boxplot() +
  labs(
    title = "Data Value in 2006 by Response",
    x = "Response",
    y = "Data Value")

# plot 2 (2010) 
plot_2010 = 
  brfss %>% 
  filter( year == 2010, state == "NY") %>% 
  ggplot(aes(x = response, y = data_value)) + 
  geom_boxplot() + 
  labs(
    title = "Data Value in 2010 by Response",
    x = "Response",
    y = "Data Value")

# panel plots
plot_2006 + plot_2010
```



## Problem 3

# Load, tidy, and otherwise wrangle the data. 
-- Your final dataset should include all originally observed variables and values; (?)- so dont tidy?? does this mean keep the variables as is?
-- have useful variable names; 
-- include a weekday vs weekend variable; 
-- and encode data with reasonable variable classes. 
-- Describe the resulting dataset (e.g. what variables exist, how many observations, etc).

way 1: (keeping original variables)
```{r}
accel_1 = 
  read_csv("./data/accel_data.csv") %>% 
  janitor::clean_names() %>% 
  mutate(day_type = replace( day , 
                             day %in% c("Saturday", "Sunday"),
                             "weekend"), 
         day_type = replace( day_type , 
                             day %in% c("Monday", "Tuesday", "Wednesday", "Thursday", "Friday"),
                             "weekday")) %>% 
  select( week, day_id, day, day_type, everything())
```

way 2: tidy to long 
```{r}
accel_2 = 
  read_csv("./data/accel_data.csv") %>% 
  janitor::clean_names() %>% 
  pivot_longer(
    activity_1:activity_1440,
    names_to = "minute_num", 
    values_to = "activity_count", 
    names_prefix = "activity_") %>% 
  mutate( minute_num = as.numeric(minute_num), 
          day_type = replace( day , 
                             day %in% c("Saturday", "Sunday"),
                             "weekend"), 
         day_type = replace( day_type , 
                             day %in% c("Monday", "Tuesday", "Wednesday", "Thursday", "Friday"),
                             "weekday")) %>% 
  select( week, day_id, day, day_type, everything())
```

# DESCRIBE DATASET (resulting dataset (e.g. what variables exist, how many observations, etc))


# Traditional analyses of accelerometer data focus on the total activity over the day. Using your tidied dataset, aggregate accross minutes to create a total activity variable for each day, and create a table showing these totals. Are any trends apparent?

can do for accel 2 but not 1
```{r}
# make table wide?
table_total_activity = 
  accel_2 %>% 
  group_by(day_id) %>% 
  summarize( total_activity = sum(activity_count))

# look for trends
accel_2 %>% 
  group_by(day_id) %>% 
  summarize( total_activity = sum(activity_count)) %>% 
  ggplot(aes(x = day_id, y = total_activity)) +
  geom_point()
```

# Accelerometer data allows the inspection activity over the course of the day. Make a single-panel plot that shows the 24-hour activity time courses for each day and use color to indicate day of the week. Describe in words any patterns or conclusions you can make based on this graph.

# need to make minutes into hours 
```{r}
accel_2 %>% 
  ggplot(aes(x = minute_num, y = activity_count, color = day)) +
  geom_point() +
  geom_line(aes(group = day_id))

accel_2 %>% 
  mutate(hour_conv = minute_num/60, 
         hour = rep(rep(0:23, each = 60), each = 35)) %>% 
  ggplot(aes(x = hour, y = activity_count, color = day)) +
  geom_point() +
  geom_line(aes(group = day_id))
  
  
  
  mutate(hour = replace( hour_conv , 
                             hour_conv < 2, 1 %in% c("Saturday", "Sunday"),
                             "weekend"), 
         day_type = replace( day_type , 
                             day %in% c("Monday", "Tuesday", "Wednesday", "Thursday", "Friday"),
                             "weekday")) 
```

# COMMENT 
